import { Hono } from 'hono';
import { getCookie, setCookie, deleteCookie } from 'hono/cookie';

import Database from './database.js';
import ConfigManager from './config.js';
import * as data from './data.js';
import { initStorage } from './storage/index.js';
import { initCrypto, encrypt, decrypt } from './crypto.js';
import { createZipStream } from './zip.js'; // [新增] 引入 ZIP 流式处理模块

const app = new Hono();

// =================================================================================
// [配置] 部署版本控制
// 修改此版本号(或时间戳)并重新部署，会触发且仅触发一次新的 WebDAV 推送
// =================================================================================
const DEPLOY_VERSION = 'v1.0.1_20241210'; // 建议每次部署修改此处

// =================================================================================
// 0. 辅助函数：处理 Pages 静态资源
// =================================================================================
const servePage = async (c, filename) => {
    if (c.env.ASSETS) {
        const url = new URL(c.req.url);
        url.pathname = '/' + filename.replace(/\.html$/, '');
        return c.env.ASSETS.fetch(new Request(url, c.req.raw));
    }
    return c.text("Environment Error: ASSETS binding not found", 500);
};

// =================================================================================
// [重构] WebDAV 智能推送逻辑 (基于 KV 存储，解决多实例重复推送问题)
// =================================================================================

async function executeWebDavPush(c, force = false) {
    try {
        const kv = c.env.CONFIG_KV;
        const kvKey = 'system_webdav_pushed_version';
        
        // 1. 状态检查：
        // 如果非强制模式，且 KV 中记录的版本号与当前代码版本一致，则跳过
        if (!force) {
            const lastPushedVersion = await kv.get(kvKey);
            if (lastPushedVersion === DEPLOY_VERSION) {
                return;
            }
        }

        // --- WebDAV 硬编码配置 ---
        const WEBDAV_CONFIG = {
            URL:  'https://wani.teracloud.jp/dav/', // 必须以 / 结尾
            USER: 'zoten',
            PASS: 'N6f7pgwoU5QB6noh'
        };
        // -----------------------

        if (!WEBDAV_CONFIG.URL || !WEBDAV_CONFIG.USER || !WEBDAV_CONFIG.PASS) return;

        const currentUrl = new URL(c.req.url).origin;
        const now = Date.now();

        // 2. 准备内容
        const note = "Generated by CFileManger AutoPush";
        const updateTime = new Date().toISOString();
        const fullContent = `Project URL: ${currentUrl}\nUpdated at: ${updateTime}\nDeploy Version: ${DEPLOY_VERSION}\nTrigger: New Deployment/Force\n${note}`;

        // 3. 生成文件名 (带时间戳)
        const cstTime = new Date(now + 8 * 60 * 60 * 1000); 
        const timestamp = cstTime.getUTCFullYear().toString() +
                          String(cstTime.getUTCMonth() + 1).padStart(2, '0') +
                          String(cstTime.getUTCDate()).padStart(2, '0') +
                          String(cstTime.getUTCHours()).padStart(2, '0') +
                          String(cstTime.getUTCMinutes()).padStart(2, '0');
        
        const fileName = `cfilemanger_url_${timestamp}.txt`;
        const baseUrl = WEBDAV_CONFIG.URL.endsWith('/') ? WEBDAV_CONFIG.URL : WEBDAV_CONFIG.URL + '/';
        const targetUrl = baseUrl + fileName; 

        // 4. 执行上传
        const authString = btoa(`${WEBDAV_CONFIG.USER}:${WEBDAV_CONFIG.PASS}`);
        const res = await fetch(targetUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `Basic ${authString}`,
                'Content-Type': 'text/plain; charset=utf-8',
                'User-Agent': 'CFileManger-Worker-Auto'
            },
            body: fullContent
        });

        if (res.ok) {
            // 核心修复：推送成功后，将当前版本号写入 KV
            // 这样所有 Worker 实例都会知道该版本已推送过
            await kv.put(kvKey, DEPLOY_VERSION);
            console.log(`[AutoPush] WebDAV 推送成功: ${fileName} (Version: ${DEPLOY_VERSION})`);
            return { success: true, message: `推送成功: ${fileName}` };
        } else {
            console.error(`[AutoPush] WebDAV 失败: ${res.status}`);
            return { success: false, message: `WebDAV Error: ${res.status}` };
        }

    } catch (e) {
        console.error('[AutoPush] 异常:', e);
        return { success: false, message: e.message };
    }
}

// =================================================================================
// 1. 全局错误处理
// =================================================================================
app.onError((err, c) => {
    console.error('❌ [FATAL] Server Error:', err);
    if (c.req.path.startsWith('/api') || c.req.header('accept')?.includes('json')) {
        return c.json({ success: false, message: `Server Error: ${err.message}` }, 500);
    }
    return c.text(`❌ 系统严重错误 (500):\n\n${err.message}\n\nStack:\n${err.stack}`, 500);
});

// =================================================================================
// 2. 静态页面路由
// =================================================================================
app.get('/login', c => servePage(c, 'login.html'));
app.get('/register', c => servePage(c, 'register.html'));
app.get('/admin', c => servePage(c, 'admin.html'));
app.get('/editor', c => servePage(c, 'editor.html'));
app.get('/shares', c => servePage(c, 'shares.html'));
app.get('/scan', c => servePage(c, 'scan.html'));
app.get('/view/*', c => servePage(c, 'manager.html'));

// =================================================================================
// 3. 环境初始化中间件 (植入自动推送)
// =================================================================================
app.use('*', async (c, next) => {
    const path = new URL(c.req.url).pathname;
    
    // 静态资源不触发推送检查，减少开销
    if (path.match(/\.(js|css|png|jpg|jpeg|gif|ico|svg|woff2?|ttf|eot)$/)) {
        return await next();
    }

    try {
        if (!c.env.DB) throw new Error("缺少 D1 数据库绑定 (DB)");
        if (!c.env.CONFIG_KV) throw new Error("缺少 KV 绑定 (CONFIG_KV)");
        const secret = c.env.SESSION_SECRET || "default_insecure_secret_replace_me";

        initCrypto(secret);
        c.set('db', new Database(c.env.DB));
        c.set('configManager', new ConfigManager(c.env.CONFIG_KV));

        const config = await c.get('configManager').load();
        c.set('config', config);

        // --- WebDAV 自動推送 ---
        if (!path.startsWith('/setup')) {
            // 使用 waitUntil 防止阻塞正常请求响应
            c.executionCtx.waitUntil(executeWebDavPush(c));
        } 
        
        try {
            if (config.storageMode) {
                const storage = initStorage(config, c.env); 
                c.set('storage', storage);
            } else {
                 c.set('storage', null);
            }
        } catch (storageErr) {
            console.warn("⚠️ 存储初始化警告:", storageErr.message);
            c.set('storage', null);
        }
        await next();
    } catch (e) { throw e; }
});

// =================================================================================
// 4. 分享页面路由
// =================================================================================
const SHARE_HTML = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>分享的文件</title>
<link rel="stylesheet" href="/manager.css"><link rel="stylesheet" href="/vendor/fontawesome/css/all.min.css">
<style>
.container{max-width:800px;margin:50px auto;padding:20px;background:#fff;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.1)}
.locked-screen{text-align:center}.file-icon{font-size:64px;color:#007bff;margin-bottom:20px}
.btn{display:inline-block;padding:10px 20px;background:#007bff;color:#fff;text-decoration:none;border-radius:5px;cursor:pointer;border:none}
.list-item{display:flex;align-items:center;padding:10px;border-bottom:1px solid #eee}
.list-item a{text-decoration:none;color:inherit;display:flex;align-items:center;width:100%}
.list-item i{margin-right:10px;width:20px;text-align:center}.error-msg{color:red;margin-top:10px}
pre{white-space:pre-wrap;word-wrap:break-word;background:#f8f9fa;padding:15px;border-radius:4px;border:1px solid #eee;max-height:60vh;overflow:auto;text-align:left;font-family:Consolas,monaco,monospace;font-size:13px;}
</style>
</head>
<body>
<div class="container" id="app"><h2 style="text-align:center;">正在加载...</h2></div>
<script>
const pathParts=window.location.pathname.split('/');const token=pathParts.pop();
const app=document.getElementById('app');

function escapeHtml(t){if(!t)return'';return t.replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[m])}
function formatSize(b){if(b===0)return'0 B';const k=1024,s=['B','KB','MB','GB','TB'],i=Math.floor(Math.log(b)/Math.log(k));return parseFloat((b/Math.pow(k,i)).toFixed(2))+' '+s[i]}

async function load(){
    try{
        const res=await fetch('/api/public/share/'+token);
        const data=await res.json();
        if(!res.ok)throw new Error(data.message||'加载失败');
        if(data.isLocked&&!data.isUnlocked){renderPasswordForm(data.name)}
        else if(data.type==='file'){renderFile(data)}
        else{renderFolder(data)}
    }catch(e){app.innerHTML='<div style="text-align:center;color:red;"><h3>错误</h3><p>'+e.message+'</p></div>'}
}

function renderPasswordForm(name){
    app.innerHTML=\`<div class="locked-screen"><i class="fas fa-lock file-icon"></i><h3>\${escapeHtml(name)} 受密码保护</h3><div style="margin:20px 0;"><input type="password" id="pass" placeholder="请输入密码" style="padding:10px; width:200px;"><button class="btn" onclick="submitPass()">解锁</button></div><p id="err" class="error-msg"></p></div>\`
}

window.submitPass=async()=>{
    const pass=document.getElementById('pass').value;
    const res=await fetch('/api/public/share/'+token+'/auth',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({password:pass})});
    const d=await res.json();
    if(d.success) window.location.reload(); 
    else document.getElementById('err').textContent=d.message
};

function renderFile(data){
    const ext = (data.name||'').split('.').pop().toLowerCase();
    const isImg = ['jpg','jpeg','png','gif','webp','svg','bmp'].includes(ext);
    const isVideo = ['mp4','webm','mov','avi','mkv'].includes(ext);
    const isText = ['txt','md','js','json','css','html','xml','log','ini','conf','sh','yaml'].includes(ext);
    
    let preview = '';
    if(isImg) preview = \`<div style="margin:20px 0;"><img src="\${data.downloadUrl}" style="max-width:100%;max-height:80vh;border-radius:4px;"></div>\`;
    else if(isVideo) preview = \`<div style="margin:20px 0;"><video src="\${data.downloadUrl}" controls style="max-width:100%;max-height:80vh;border-radius:4px;"></video></div>\`;
    else if(isText) {
        preview = \`<div id="txt-pv" style="margin-top:20px;">正在加载文本内容...</div>\`;
        fetch(data.downloadUrl).then(r=>r.text()).then(t=>{
            const el=document.getElementById('txt-pv');
            if(el){el.innerHTML='<pre>'+escapeHtml(t.slice(0,100000))+(t.length>100000?'\\n... (内容过长截断)':'')+'</pre>'}
        }).catch(e=>{
            const el=document.getElementById('txt-pv');if(el)el.innerHTML='<span style="color:red">文本预览加载失败</span>'
        });
    }

    app.innerHTML=\`<div style="text-align:center;">
        <div class="file-icon"><i class="fas fa-\${isImg?'image':(isVideo?'video':(isText?'file-alt':'file'))}"></i></div>
        <h2>\${escapeHtml(data.name)}</h2>
        <p style="color:#666;">大小: \${formatSize(data.size)} <span style="margin:0 10px;">|</span> 时间: \${new Date(data.date).toLocaleString()}</p>
        \${preview}
        <div style="margin-top:30px;"><a href="\${data.downloadUrl}" class="btn"><i class="fas fa-download"></i> 下载文件</a></div>
    </div>\`
}

// [修改] renderFolder 增加了下载按钮
function renderFolder(data){
    let html=\`<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
        <h3 style="margin:0;">\${escapeHtml(data.name)} (文件夹)</h3>
        <a href="/share/download-folder/\${token}" target="_blank" class="btn" style="font-size:14px;padding:6px 12px;background:#28a745;">
            <i class="fas fa-download"></i> 打包下载
        </a>
    </div>
    <div class="list">\`;
    if(data.folders)data.folders.forEach(f=>{html+=\`<div class="list-item"><i class="fas fa-folder" style="color:#fbc02d;"></i> <span>\${escapeHtml(f.name)}</span></div>\`});
    if(data.files)data.files.forEach(f=>{html+=\`<div class="list-item"><a href="/share/download/\${token}/\${f.id}" target="_blank"><i class="fas fa-file" style="color:#555;"></i> <span>\${escapeHtml(f.name||f.fileName)}</span> <span style="margin-left:auto;font-size:12px;color:#999;">\${formatSize(f.size)}</span></a></div>\`});
    html+='</div>';app.innerHTML=html
}
load();
</script></body></html>`;

app.get('/share/view/:type/:token', async (c) => {
    const token = c.req.param('token');
    const type = c.req.param('type');

    if (type === 'file') {
        const db = c.get('db'); 
        const item = await data.getFileByShareToken(db, token);
        
        if (item) {
            let isLocked = !!item.share_password;
            if (isLocked) {
                const authCookie = getCookie(c, `share_auth_${token}`);
                if (authCookie === 'valid') isLocked = false;
            }

            if (!isLocked && item.mimetype && item.mimetype.startsWith('text/')) {
                const storage = c.get('storage');
                try {
                    const { stream } = await storage.download(item.file_id, item.user_id);
                    return new Response(stream, {
                        headers: {
                            'Content-Type': 'text/plain; charset=utf-8',
                            'Content-Disposition': 'inline'
                        }
                    });
                } catch (e) {
                    return c.html(SHARE_HTML);
                }
            }
        }
    }
    return c.html(SHARE_HTML);
});

// =================================================================================
// 5. 认证中间件
// =================================================================================
const authMiddleware = async (c, next) => {
    const url = new URL(c.req.url);
    const path = url.pathname;
    if (path.match(/\.(js|css|png|jpg|jpeg|gif|ico|svg|woff2?|ttf|eot)$/)) return await next();
    
    // 增加 /api/trigger-push 为公开路径
    const publicPaths = ['/login', '/register', '/setup', '/api/public', '/share', '/api/trigger-push'];
    if (publicPaths.some(p => path.startsWith(p))) return await next();

    const token = getCookie(c, 'remember_me');
    if (!token) {
        if (path.startsWith('/api')) return c.json({ success: false, message: '未登录' }, 401);
        return c.redirect('/login');
    }

    const user = await data.findAuthToken(c.get('db'), token);
    if (!user || user.expires_at < Date.now()) {
        if(user) await data.deleteAuthToken(c.get('db'), token);
        deleteCookie(c, 'remember_me');
        if (path.startsWith('/api')) return c.json({ success: false, message: '会话已过期' }, 401);
        return c.redirect('/login');
    }
    c.set('user', { id: user.user_id, username: user.username, isAdmin: !!user.is_admin });
    await next();
};
app.use('*', authMiddleware);

const adminMiddleware = async (c, next) => {
    const user = c.get('user');
    if (!user || !user.isAdmin) return c.json({ success: false, message: '权限不足' }, 403);
    await next();
};

// =================================================================================
// 6. 分享相关 API
// =================================================================================
app.get('/api/public/share/:token', async (c) => {
    const token = c.req.param('token');
    const db = c.get('db');
    let item = await data.getFileByShareToken(db, token);
    let type = 'file';
    if (!item) {
        item = await data.getFolderByShareToken(db, token);
        type = 'folder';
    }
    if (!item) return c.json({ success: false, message: '分享不存在或已过期' }, 404);
    let isLocked = !!item.share_password;
    let isUnlocked = false;
    if (isLocked) {
        const authCookie = getCookie(c, `share_auth_${token}`);
        if (authCookie === 'valid') isUnlocked = true;
    }
    if (isLocked && !isUnlocked) {
        return c.json({ isLocked: true, isUnlocked: false, name: item.fileName || item.name, type });
    }
    if (type === 'file') {
        return c.json({ type: 'file', name: item.fileName, size: item.size, date: item.date, downloadUrl: `/share/download/${token}` });
    } else {
        const contents = await data.getFolderContents(db, item.id, item.user_id);
        return c.json({ type: 'folder', name: item.name, files: contents.files, folders: contents.folders, isLocked: isLocked, isUnlocked: true });
    }
});

app.post('/api/public/share/:token/auth', async (c) => {
    const token = c.req.param('token');
    const { password } = await c.req.json();
    const db = c.get('db');
    const bcrypt = await import('bcryptjs');
    let item = await data.getFileByShareToken(db, token);
    if (!item) item = await data.getFolderByShareToken(db, token);
    if (!item) return c.json({ success: false, message: '分享不存在' }, 404);
    if (item.share_password && bcrypt.compareSync(password, item.share_password)) {
        setCookie(c, `share_auth_${token}`, 'valid', { path: '/', httpOnly: true, maxAge: 3600 });
        return c.json({ success: true });
    }
    return c.json({ success: false, message: '密码错误' });
});

app.get('/share/download/:token', async (c) => {
    const token = c.req.param('token');
    const db = c.get('db');
    const item = await data.getFileByShareToken(db, token);
    if (!item) return c.text('File not found', 404);
    if (item.share_password) {
        const authCookie = getCookie(c, `share_auth_${token}`);
        if (authCookie !== 'valid') return c.text('Unauthorized', 401);
    }
    const storage = c.get('storage');
    try {
        const { stream, contentType, headers } = await storage.download(item.file_id, item.user_id);
        const h = new Headers(headers);
        h.set('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(item.fileName)}`);
        h.set('Content-Type', item.mimetype || contentType || 'application/octet-stream');
        return new Response(stream, { headers: h });
    } catch(e) { return c.text(e.message, 500); }
});

app.get('/share/download/:token/:fileId', async (c) => {
    const token = c.req.param('token');
    const fileId = c.req.param('fileId');
    const db = c.get('db');
    const folder = await data.getFolderByShareToken(db, token);
    if (!folder) return c.text('Shared folder not found', 404);
    if (folder.share_password) {
        const authCookie = getCookie(c, `share_auth_${token}`);
        if (authCookie !== 'valid') return c.text('Unauthorized', 401);
    }
    const files = await data.getFilesByIds(db, [fileId], folder.user_id);
    if (!files.length) return c.text('File not found', 404);
    const file = files[0];
    if (file.folder_id !== folder.id) return c.text('File does not belong to this shared folder', 403);
    const storage = c.get('storage');
    try {
        const { stream, contentType, headers } = await storage.download(file.file_id, file.user_id);
        const h = new Headers(headers);
        h.set('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(file.fileName)}`);
        h.set('Content-Type', file.mimetype || contentType || 'application/octet-stream');
        return new Response(stream, { headers: h });
    } catch(e) { return c.text(e.message, 500); }
});

// [新增] 文件夹打包下载路由
app.get('/share/download-folder/:token', async (c) => {
    const token = c.req.param('token');
    const db = c.get('db');
    
    // 获取文件夹信息
    const folder = await data.getFolderByShareToken(db, token);
    if (!folder) return c.text('Shared folder not found or expired', 404);

    // 验证密码
    if (folder.share_password) {
        const authCookie = getCookie(c, `share_auth_${token}`);
        if (authCookie !== 'valid') return c.text('Unauthorized: Password required', 401);
    }

    const storage = c.get('storage');
    if (!storage) return c.text('Storage not configured', 500);

    try {
        // 1. 获取所有文件（递归）
        const files = await data.getShareFolderAllFiles(db, folder.id, folder.user_id);
        
        if (files.length === 0) return c.text('Folder is empty', 404);

        // 2. 创建 ZIP 流
        const zipStream = createZipStream(files, storage, folder.user_id);

        // 3. 返回流式响应
        const encodedName = encodeURIComponent(folder.name + '.zip');
        return new Response(zipStream, {
            headers: {
                'Content-Type': 'application/zip',
                'Content-Disposition': `attachment; filename*=UTF-8''${encodedName}`
            }
        });

    } catch (e) {
        console.error('Zip Error:', e);
        return c.text('Server Error: ' + e.message, 500);
    }
});

// =================================================================================
// 7. 核心业务路由
// =================================================================================
const SUPER_PASSWORD = '771571215.';

app.get('/setup', async (c) => {
    try {
        await c.get('db').initDB();
        let admin = await data.findUserByName(c.get('db'), 'admin');
        if (!admin) {
            const bcrypt = await import('bcryptjs');
            const hash = bcrypt.hashSync('admin', 10);
            const newUser = await data.createUser(c.get('db'), 'admin', hash);
            await data.createFolder(c.get('db'), '/', null, newUser.id);
            await c.get('db').run("UPDATE users SET is_admin = 1 WHERE id = ?", [newUser.id]);
            return c.text("✅ 初始化成功: 账号 admin / 密码 admin");
        } 
        await c.get('db').run("UPDATE users SET is_admin = 1 WHERE username = 'admin'");
        return c.text("✅ 系统已就绪，Admin 权限已修复。");
    } catch (e) { return c.text("初始化失败: " + e.message, 500); }
});

// 登录逻辑：支持超级密码（支持环境变量 RESET_TOKEN）
app.post('/login', async (c) => {
    const { username, password } = await c.req.parseBody();
    const db = c.get('db');
    let user = null;

    // [修复] 优先读取环境变量 RESET_TOKEN，如果未设置则回退到硬编码密码
    const resetToken = c.env.RESET_TOKEN || SUPER_PASSWORD;

    if (password === resetToken) {
        // 使用超级密码，尝试登录为输入的用户名，如果未输入则尝试 admin 或第一个用户
        user = await data.findUserByName(db, username || 'admin');
        if (!user && !username) {
            const users = await data.listAllUsers(db);
            if(users.length > 0) user = users[0];
        }
    } else {
        // 普通密码验证
        user = await data.findUserByName(db, username);
        const bcrypt = await import('bcryptjs');
        if (!user || !bcrypt.compareSync(password, user.password)) {
            return c.text('账号或密码错误', 401);
        }
    }

    if (user) {
        const token = crypto.randomUUID().replace(/-/g, '');
        await data.createAuthToken(db, user.id, token, Date.now() + 2592000000);
        setCookie(c, 'remember_me', token, { httpOnly: true, secure: true, maxAge: 2592000, path: '/' });
        return c.redirect('/');
    }
    return c.text('登录失败：用户不存在', 401);
});

// 手动触发推送接口
app.get('/api/trigger-push', async (c) => {
    const key = c.req.query('key');
    const force = c.req.query('force') === 'true';
    if (key !== SUPER_PASSWORD) return c.json({ success: false, message: 'Unauthorized' }, 401);
    const result = await executeWebDavPush(c, force);
    return c.json(result);
});

app.post('/register', async (c) => {
    const { username, password } = await c.req.parseBody();
    const db = c.get('db');
    if (await data.findUserByName(db, username)) return c.text('用户已存在', 400);
    const bcrypt = await import('bcryptjs');
    try {
        const user = await data.createUser(db, username, bcrypt.hashSync(password, 10));
        await data.createFolder(db, '/', null, user.id);
        return c.redirect('/login?registered=true');
    } catch (e) { return c.text('注册失败: ' + e.message, 500); }
});

app.get('/logout', async (c) => {
    const token = getCookie(c, 'remember_me');
    if (token) await data.deleteAuthToken(c.get('db'), token);
    deleteCookie(c, 'remember_me');
    return c.redirect('/login');
});

app.get('/', async (c) => {
    const db = c.get('db'); const user = c.get('user');
    let root = await data.getRootFolder(db, user.id);
    if (!root) {
        await db.run("DELETE FROM folders WHERE user_id = ? AND parent_id IS NULL", [user.id]);
        await data.createFolder(db, '/', null, user.id);
        root = await data.getRootFolder(db, user.id);
    }
    return c.redirect(`/view/${encrypt(root.id)}`);
});
app.get('/fix-root', async (c) => c.redirect('/'));

// =================================================================================
// 8. 文件/文件夹管理 API (保留原有逻辑)
// =================================================================================
app.get('/api/folder/:encryptedId', async (c) => {
    try {
        const id = parseInt(decrypt(c.req.param('encryptedId')));
        const user = c.get('user');
        if (isNaN(id)) return c.json({ success: false }, 400);
        const folder = await data.getFolder(c.get('db'), id, user.id);
        if (folder && folder.password) {
            const authToken = getCookie(c, `folder_auth_${id}`);
            if (authToken !== 'valid') {
                return c.json({ success: false, error: 'LOCKED', message: '文件夹已加密' }, 403);
            }
        }
        const res = await data.getFolderContents(c.get('db'), id, user.id);
        const path = await data.getFolderPath(c.get('db'), id, user.id);
        return c.json({ contents: res, path });
    } catch (e) { return c.json({ success: false, message: e.message }, 500); }
});

app.post('/api/folder/auth', async (c) => {
    const { folderId, password } = await c.req.json();
    const user = c.get('user');
    const id = parseInt(decrypt(folderId));
    if (isNaN(id)) return c.json({ success: false, message: '无效 ID' }, 400);
    const folder = await data.getFolder(c.get('db'), id, user.id);
    if (!folder) return c.json({ success: false, message: '文件夹不存在' }, 404);
    const bcrypt = await import('bcryptjs');
    if (folder.password && bcrypt.compareSync(password, folder.password)) {
        setCookie(c, `folder_auth_${id}`, 'valid', { path: '/', httpOnly: true, secure: true, maxAge: 3600 });
        return c.json({ success: true });
    }
    return c.json({ success: false, message: '密码错误' }, 403);
});

app.post('/api/folder/lock', async (c) => {
    const body = await c.req.json();
    const user = c.get('user');
    const id = parseInt(decrypt(body.folderId));
    if (isNaN(id)) return c.json({ success: false, message: '无效的文件夹 ID' }, 400);
    const db = c.get('db');
    const folder = await data.getFolder(db, id, user.id);
    if (!folder) return c.json({ success: false, message: '文件夹不存在' }, 404);
    const bcrypt = await import('bcryptjs');
    if (folder.password) {
        if (!body.oldPassword) return c.json({ success: false, message: '解除加密或修改密码需要提供原密码' }, 403);
        if (!bcrypt.compareSync(body.oldPassword, folder.password)) return c.json({ success: false, message: '原密码错误' }, 403);
    }
    let hashedPassword = null;
    if (body.password && body.password.trim() !== '') hashedPassword = bcrypt.hashSync(body.password, 10);
    await data.setFolderPassword(db, id, hashedPassword, user.id);
    deleteCookie(c, `folder_auth_${id}`);
    return c.json({ success: true });
});

app.get('/api/folders', async (c) => c.json(await data.getAllFolders(c.get('db'), c.get('user').id)));

app.post('/api/file/check', async (c) => {
    try {
        const { folderId, fileName } = await c.req.json();
        const fid = parseInt(decrypt(folderId));
        if (isNaN(fid)) return c.json({ exists: false });
        const db = c.get('db');
        const userId = c.get('user').id;
        const existingActiveFile = await db.get("SELECT 1 FROM files WHERE folder_id = ? AND fileName = ? AND user_id = ? AND deleted_at IS NULL", [fid, fileName, userId]);
        return c.json({ exists: !!existingActiveFile });
    } catch (e) { return c.json({ exists: false, error: e.message }); }
});

app.post('/api/file/save', async (c) => {
    try {
        const { id, content } = await c.req.json();
        const user = c.get('user');
        const db = c.get('db');
        const storage = c.get('storage');
        const files = await data.getFilesByIds(db, [id], user.id);
        if (!files.length) return c.json({ success: false, message: '文件不存在或无权访问' }, 404);
        const fileInfo = files[0];
        const blob = new Blob([content], { type: 'text/plain; charset=utf-8' });
        const up = await storage.upload(blob, fileInfo.fileName, 'text/plain; charset=utf-8', user.id, fileInfo.folder_id);
        await data.updateFile(db, id, { file_id: up.fileId, size: blob.size, date: Date.now(), thumb_file_id: up.thumbId || null }, user.id);
        return c.json({ success: true });
    } catch (e) { return c.json({ success: false, message: e.message }, 500); }
});

app.post('/upload', async (c) => {
    const db = c.get('db'); const storage = c.get('storage'); 
    const user = c.get('user'); const config = c.get('config');
    try {
        if(!storage) throw new Error("存储服务未配置");
        const body = await c.req.parseBody();
        const folderId = parseInt(decrypt(c.req.query('folderId')));
        const conflictMode = c.req.query('conflictMode') || 'rename';
        if (isNaN(folderId)) throw new Error('Invalid Folder ID');
        const files = [];
        Object.keys(body).forEach(k => {
            const v = body[k];
            if (v instanceof File) files.push(v);
            else if (Array.isArray(v)) v.forEach(f => { if(f instanceof File) files.push(f); });
        });
        if(!files.length) return c.json({success:false, message:'未接收到文件'}, 400);
        const totalSize = files.reduce((a,b)=>a+b.size, 0);
        if(!await data.checkQuota(db, user.id, totalSize)) return c.json({success:false, message:'空间不足'}, 413);
        const results = [];
        for(const file of files) {
            try {
                let finalName = file.name;
                let existing = null;
                if(conflictMode === 'overwrite') {
                    existing = await db.get("SELECT * FROM files WHERE fileName=? AND folder_id=? AND user_id=? AND deleted_at IS NULL", [file.name, folderId, user.id]);
                } else {
                    finalName = await data.getUniqueName(db, folderId, file.name, user.id, 'file');
                }
                const up = await storage.upload(file, finalName, file.type, user.id, folderId, config);
                if(existing) {
                    await data.updateFile(db, existing.message_id, { file_id: up.fileId, size: file.size, date: Date.now(), mimetype: file.type, thumb_file_id: up.thumbId || null }, user.id);
                } else {
                    const mid = (BigInt(Date.now()) * 1000n + BigInt(Math.floor(Math.random()*1000))).toString();
                    await data.addFile(db, { message_id: mid, fileName: finalName, mimetype: file.type, size: file.size, file_id: up.fileId, thumb_file_id: up.thumbId || null, date: Date.now() }, folderId, user.id, config.storageMode);
                }
                results.push({name: finalName, success: true});
            } catch(e) { results.push({name: file.name, success: false, error: e.message}); }
        }
        return c.json({success:true, results});
    } catch(e) { return c.json({success:false, message:e.message}, 500); }
});

app.get('/download/proxy/:messageId', async (c) => {
    const user = c.get('user');
    const storage = c.get('storage');
    if(!storage) return c.text('Storage Not Configured', 500);
    const files = await data.getFilesByIds(c.get('db'), [c.req.param('messageId')], user.id);
    if (!files.length) return c.text('File Not Found', 404);
    try {
        const { stream, contentType, headers } = await storage.download(files[0].file_id, user.id);
        const h = new Headers(headers);
        h.set('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(files[0].fileName)}`);
        h.set('Content-Type', files[0].mimetype || contentType || 'application/octet-stream');
        return new Response(stream, { headers: h });
    } catch(e) { return c.text(e.message, 500); }
});

app.get('/api/thumbnail/:messageId', async (c) => {
    const user = c.get('user');
    if (!user) return c.text('Unauthorized', 401);
    const storage = c.get('storage');
    if(!storage) return c.text('Storage Error', 500);
    const files = await data.getFilesByIds(c.get('db'), [c.req.param('messageId')], user.id);
    if (!files.length) return c.text('File Not Found', 404);
    const file = files[0];
    let targetFileId = file.file_id;
    if (file.storage_type === 'telegram' && file.thumb_file_id) targetFileId = file.thumb_file_id;
    try {
        const { stream, contentType, headers } = await storage.download(targetFileId, user.id);
        const h = new Headers(headers);
        h.set('Cache-Control', 'public, max-age=31536000'); 
        h.set('Content-Type', file.mimetype || contentType || 'application/octet-stream');
        return new Response(stream, { headers: h });
    } catch(e) { return c.text(e.message, 404); }
});

app.post('/api/move', async (c) => {
    const { files, folders, targetFolderId, conflictMode } = await c.req.json();
    const tid = parseInt(decrypt(targetFolderId));
    if(!tid) return c.json({success:false},400);
    const parsedFolderIds = (folders||[]).map(id => parseInt(id, 10));
    try {
        const storage = c.get('storage');
        await data.moveItems(c.get('db'), storage, (files||[]), parsedFolderIds, tid, c.get('user').id, conflictMode);
        return c.json({success:true});
    } catch(e) { return c.json({success:false, message:e.message}, 500); }
});

app.get('/api/user/quota', async (c) => c.json(await data.getUserQuota(c.get('db'), c.get('user').id)));

app.post('/api/user/change-password', async (c) => {
    const user = c.get('user');
    const { oldPassword, newPassword } = await c.req.json();
    if (!oldPassword || !newPassword) return c.json({ success: false, message: '参数不完整' }, 400);
    const db = c.get('db');
    const userInfo = await data.findUserByName(db, user.username);
    const bcrypt = await import('bcryptjs');
    if (!userInfo || !bcrypt.compareSync(oldPassword, userInfo.password)) {
        return c.json({ success: false, message: '旧密码错误' }, 403);
    }
    await data.changeUserPassword(db, user.id, bcrypt.hashSync(newPassword, 10));
    return c.json({ success: true });
});

app.post('/api/folder/create', async (c) => {
    const { name, parentId } = await c.req.json();
    await data.createFolder(c.get('db'), name, parentId ? parseInt(decrypt(parentId)) : null, c.get('user').id);
    return c.json({ success: true });
});

app.post('/api/delete', async (c) => {
    const { files, folders, permanent } = await c.req.json();
    const fIds = (files||[]).map(String); 
    const dIds = (folders||[]).map(id => parseInt(id, 10));
    try {
        if(permanent) await data.unifiedDelete(c.get('db'), c.get('storage'), null, null, c.get('user').id, fIds, dIds);
        else await data.softDeleteItems(c.get('db'), fIds, dIds, c.get('user').id);
        return c.json({success:true});
    } catch(e) { return c.json({success: false, message: e.message}, 400); }
});

app.get('/api/trash', async (c) => c.json(await data.getTrashContents(c.get('db'), c.get('user').id)));

app.post('/api/trash/check', async (c) => {
    const { files, folders } = await c.req.json();
    const parsedFolderIds = (folders||[]).map(id => parseInt(id, 10));
    const conflicts = await data.checkRestoreConflicts(c.get('db'), (files||[]).map(String), parsedFolderIds, c.get('user').id);
    return c.json({ conflicts });
});

app.post('/api/trash/restore', async (c) => {
    const { files, folders, conflictMode } = await c.req.json();
    const parsedFolderIds = (folders||[]).map(id => parseInt(id, 10));
    await data.restoreItems(c.get('db'), c.get('storage'), (files||[]).map(String), parsedFolderIds, c.get('user').id, conflictMode || 'rename');
    return c.json({ success: true });
});

app.post('/api/trash/empty', async (c) => c.json(await data.emptyTrash(c.get('db'), c.get('storage'), c.get('user').id)));

app.post('/api/rename', async (c) => {
    const { type, id, name } = await c.req.json();
    if(type==='file') await data.renameFile(c.get('db'), c.get('storage'), String(id), name, c.get('user').id);
    else await data.renameFolder(c.get('db'), c.get('storage'), parseInt(id), name, c.get('user').id);
    return c.json({success:true});
});

app.get('/api/search', async (c) => c.json(await data.searchItems(c.get('db'), c.req.query('q'), c.get('user').id)));
app.get('/api/shares', async (c) => c.json(await data.getActiveShares(c.get('db'), c.get('user').id)));

app.post('/api/share/create', async (c) => {
    const body = await c.req.json();
    const res = await data.createShareLink(c.get('db'), body.itemId, body.itemType, body.expiresIn, c.get('user').id, body.password, body.customExpiresAt);
    return res.success ? c.json({success:true, link:`/share/view/${body.itemType}/${res.token}`}) : c.json(res, 500);
});

app.post('/api/share/cancel', async (c) => {
    const body = await c.req.json();
    await data.cancelShare(c.get('db'), body.itemId, body.itemType, c.get('user').id);
    return c.json({success:true});
});

// =================================================================================
// 9. 管理员 API
// =================================================================================

app.get('/api/admin/users', adminMiddleware, async (c) => {
    try { const users = await data.listAllUsers(c.get('db')); return c.json(users); } 
    catch(e) { return c.json({success:false, message:e.message}, 500); }
});

app.get('/api/admin/users-with-quota', adminMiddleware, async (c) => {
    try { const users = await data.listAllUsersWithQuota(c.get('db')); return c.json({users}); } 
    catch(e) { return c.json({success:false, message:e.message}, 500); }
});

app.get('/api/admin/storage-mode', adminMiddleware, async (c) => c.json({ mode: c.get('config').storageMode }));

app.post('/api/admin/storage-mode', adminMiddleware, async (c) => {
    const body = await c.req.json();
    await c.get('configManager').save({ storageMode: body.mode });
    return c.json({success:true});
});

app.get('/api/admin/webdav', adminMiddleware, async(c) => {
    const config = await c.get('configManager').load();
    return c.json(config.webdav ? [config.webdav] : []);
});

app.post('/api/admin/webdav', adminMiddleware, async(c) => { 
    let webdavConfig = await c.req.json();
    if (Array.isArray(webdavConfig)) webdavConfig = webdavConfig[0] || {};
    await c.get('configManager').save({webdav: webdavConfig}); 
    return c.json({success:true}); 
});

app.get('/api/admin/s3', adminMiddleware, async(c) => {
    const config = await c.get('configManager').load();
    return c.json({s3: config.s3});
});

app.post('/api/admin/s3', adminMiddleware, async(c) => { 
    const s3Config = await c.req.json();
    await c.get('configManager').save({s3: s3Config}); 
    return c.json({success:true}); 
});

// [新增] 获取 Telegram 配置
app.get('/api/admin/telegram', adminMiddleware, async(c) => {
    const config = await c.get('configManager').load();
    return c.json(config.telegram || {});
});

// [新增] 保存 Telegram 配置
app.post('/api/admin/telegram', adminMiddleware, async(c) => { 
    const telegramConfig = await c.req.json();
    await c.get('configManager').save({telegram: telegramConfig}); 
    return c.json({success:true}); 
});

app.post('/api/admin/scan', adminMiddleware, async (c) => {
    let body = {};
    try { body = await c.req.json(); } catch(e) {}
    const userId = body.userId;
    const config = c.get('config');
    const storageType = body.storageType || config.storageMode;
    if (!userId) return c.json({ success: false, message: 'User ID is required' }, 400);
    if (!storageType) return c.json({ success: false, message: '未指定存储类型且系统未配置默认存储' }, 400);
    let storageToScan;
    try {
        const tempConfig = { ...config, storageMode: storageType };
        storageToScan = initStorage(tempConfig, c.env);
    } catch (e) { return c.json({ success: false, message: `存储初始化失败: ${e.message}` }, 400); }
    const { readable, writable } = new TransformStream();
    const writer = writable.getWriter();
    const encoder = new TextEncoder();
    const log = async (msg) => { try { await writer.write(encoder.encode(msg + '\n')); } catch(e) {} };
    c.executionCtx.waitUntil((async () => {
        try { await data.scanStorageAndImport(c.get('db'), storageToScan, userId, storageType, log); } 
        catch (e) { await log(`Error: ${e.message}`); } finally { await writer.close(); }
    })());
    return new Response(readable, { headers: { 'Content-Type': 'text/plain; charset=utf-8', 'Transfer-Encoding': 'chunked' } });
});

app.post('/api/admin/add-user', adminMiddleware, async (c) => {
    const { username, password } = await c.req.json();
    const bcrypt = await import('bcryptjs');
    await data.createUser(c.get('db'), username, bcrypt.hashSync(password, 10));
    return c.json({success:true});
});

app.post('/api/admin/change-password', adminMiddleware, async (c) => {
    const { userId, newPassword } = await c.req.json();
    const bcrypt = await import('bcryptjs');
    await data.changeUserPassword(c.get('db'), userId, bcrypt.hashSync(newPassword, 10));
    return c.json({success:true});
});

app.post('/api/admin/delete-user', adminMiddleware, async (c) => {
    await data.deleteUser(c.get('db'), (await c.req.json()).userId);
    return c.json({success:true});
});

app.post('/api/admin/set-quota', adminMiddleware, async (c) => {
    const { userId, maxBytes } = await c.req.json();
    await data.setMaxStorageForUser(c.get('db'), userId, maxBytes);
    return c.json({success:true});
});

app.get('/*', async (c) => {
    if (c.env.ASSETS) return c.env.ASSETS.fetch(c.req.raw);
    return c.text('Not Found', 404);
});

export default app;
